cbuffer PerFrame : register(b0)
{
    matrix view;
    matrix projection;
};

cbuffer PerObject : register(b1)
{
	int id;
    matrix world;
};

// Describes individual vertex data
struct VertexShaderInput
{
    float3 position		: POSITION;
    float2 uv			: TEXCOORD;
    float3 normal		: NORMAL;
};

// Defines the output data of our vertex shader
struct VertexToPixel
{
    float4 position		: SV_POSITION;
    float3 worldPos     : POSITION;
    float3 normal       : NORMAL;
    float2 uv           : TEXCOORD1;
};

#define B  32      // table size
#define B2 66      // B*2 + 2
#define BR 0.03125 // 1 / B

/*const float pg[256] = {
	-0.569811f,0.432591f,-0.698699f,0.0f,	 0.78118f, 0.163006f, 0.60265f, 1.0f,
	0.436394f,-0.297978f,0.848982f,2.0f,		0.843762f,-0.185742f,-0.503554f,3.0f,
	0.663712f,-0.68443f,-0.301731f,4.0f,        0.616757f,0.768825f,0.168875f,5.0f,
	0.457153f,-0.884439f,-0.093694f,6.0f,		-0.956955f,0.110962f,-0.268189f,7.0f,
	0.115821f,0.77523f,0.620971f,8.0f,			-0.716028f,-0.477247f,-0.50945f,9.0f,
	0.819593f,-0.123834f,0.559404f,10.0f,		-0.522782f,-0.586534f,0.618609f,11.0f,
	-0.792328f,-0.577495f,-0.196765f,12.0f,		-0.674422f,0.0572986f,0.736119f,13.0f,
	-0.224769f,-0.764775f,-0.60382f,14.0f,		0.492662f,-0.71614f,0.494396f,15.0f,

	0.470993f,-0.645816f,0.600905f,16.0f,		-0.19049f,0.321113f,0.927685f,17.0f,
	0.0122118f,0.946426f,-0.32269f,18.0f,		0.577419f,0.408182f,0.707089f,19.0f,
	-0.0945428f,0.341843f,-0.934989f,20.0f,		0.788332f,-0.60845f,-0.0912217f,21.0f,
	-0.346889f,0.894997f,-0.280445f,22.0f,		-0.165907f,-0.649857f,0.741728f,23.0f,
	0.791885f,0.124138f,0.597919f,24.0f,		-0.625952f,0.73148f,0.270409f,25.0f,
	-0.556306f,0.580363f,0.594729f,26.0f,		0.673523f,0.719805f,0.168069f,27.0f,
	-0.420334f,0.894265f,0.153656f,28.0f,		-0.141622f,-0.279389f,0.949676f,29.0f,
	-0.803343f,0.458278f,0.380291f,30.0f,		0.49355f,-0.402088f,0.77119f,31.0f,

	-0.569811f,0.432591f,-0.698699f,0.0f,		0.78118f,0.163006f,0.60265f,1.0f,
	0.436394f,-0.297978f,0.848982f,2.0f,		0.843762f,-0.185742f,-0.503554f,3.0f,
	0.663712f,-0.68443f,-0.301731f,4.0f,		0.616757f,0.768825f,0.168875f,5.0f,
	0.457153f,-0.884439f,-0.093694f,6.0f,		-0.956955f,0.110962f,-0.268189f,7.0f,
	0.115821f,0.77523f,0.620971f,8.0f,			-0.716028f,-0.477247f,-0.50945f,9.0f,
	0.819593f,-0.123834f,0.559404f,10.0f,		-0.522782f,-0.586534f,0.618609f,11.0f,
	-0.792328f,-0.577495f,-0.196765f,12.0f,		-0.674422f,0.0572986f,0.736119f,13.0f,
	-0.224769f,-0.764775f,-0.60382f,14.0f,		0.492662f,-0.71614f,0.494396f,15.0f,

	0.470993f,-0.645816f,0.600905f,16.0f,		-0.19049f,0.321113f,0.927685f,17.0f,
	0.0122118f,0.946426f,-0.32269f,18.0f,		0.577419f,0.408182f,0.707089f,19.0f,
	-0.0945428f,0.341843f,-0.934989f,20.0f,		0.788332f,-0.60845f,-0.0912217f,21.0f,
	-0.346889f,0.894997f,-0.280445f,22.0f,		-0.165907f,-0.649857f,0.741728f,23.0f,
	0.791885f,0.124138f,0.597919f,24.0f,		-0.625952f,0.73148f,0.270409f,25.0f,
	-0.556306f,0.580363f,0.594729f,26.0f,		0.673523f,0.719805f,0.168069f,27.0f,
	-0.420334f,0.894265f,0.153656f,28.0f,		-0.141622f,-0.279389f,0.949676f,29.0f,
	-0.803343f,0.458278f,0.380291f,30.0f,		0.49355f,-0.402088f,0.77119f,31.0f
};*/

const float4 pg[64] = {
	float4(-0.569811,0.432591,-0.698699,0.0),		float4(0.78118,0.163006,0.60265,1.0),
	float4(0.436394,-0.297978,0.848982,2.0),		float4(0.843762,-0.185742,-0.503554,3.0),
	float4(0.663712,-0.68443,-0.301731,4.0),		float4(0.616757,0.768825,0.168875,5.0),
	float4(0.457153,-0.884439,-0.093694,6.0),		float4(-0.956955,0.110962,-0.268189,7.0),
	float4(0.115821,0.77523,0.620971,8.0),			float4(-0.716028,-0.477247,-0.50945,9.0),
	float4(0.819593,-0.123834,0.559404,10.0),		float4(-0.522782,-0.586534,0.618609,11.0),
	float4(-0.792328,-0.577495,-0.196765,12.0),		float4(-0.674422,0.0572986,0.736119,13.0),
	float4(-0.224769,-0.764775,-0.60382,14.0),		float4(0.492662,-0.71614,0.494396,15.0),
	float4(0.470993,-0.645816,0.600905,16.0),		float4(-0.19049,0.321113,0.927685,17.0),
	float4(0.0122118,0.946426,-0.32269,18.0),		float4(0.577419,0.408182,0.707089,19.0),
	float4(-0.0945428,0.341843,-0.934989,20.0),		float4(0.788332,-0.60845,-0.0912217,21.0),
	float4(-0.346889,0.894997,-0.280445,22.0),		float4(-0.165907,-0.649857,0.741728,23.0),
	float4(0.791885,0.124138,0.597919,24.0),		float4(-0.625952,0.73148,0.270409,25.0),
	float4(-0.556306,0.580363,0.594729,26.0),		float4(0.673523,0.719805,0.168069,27.0),
	float4(-0.420334,0.894265,0.153656,28.0),		float4(-0.141622,-0.279389,0.949676,29.0),
	float4(-0.803343,0.458278,0.380291,30.0),		float4(0.49355,-0.402088,0.77119,31.0),
	float4(-0.569811,0.432591,-0.698699,0.0),		float4(0.78118,0.163006,0.60265,1.0),
	float4(0.436394,-0.297978,0.848982,2.0),		float4(0.843762,-0.185742,-0.503554,3.0),
	float4(0.663712,-0.68443,-0.301731,4.0),		float4(0.616757,0.768825,0.168875,5.0),
	float4(0.457153,-0.884439,-0.093694,6.0),		float4(-0.956955,0.110962,-0.268189,7.0),
	float4(0.115821,0.77523,0.620971,8.0),			float4(-0.716028,-0.477247,-0.50945,9.0),
	float4(0.819593,-0.123834,0.559404,10.0),		float4(-0.522782,-0.586534,0.618609,11.0),
	float4(-0.792328,-0.577495,-0.196765,12.0),		float4(-0.674422,0.0572986,0.736119,13.0),
	float4(-0.224769,-0.764775,-0.60382,14.0),		float4(0.492662,-0.71614,0.494396,15.0),
	float4(0.470993,-0.645816,0.600905,16.0),		float4(-0.19049,0.321113,0.927685,17.0),
	float4(0.0122118,0.946426,-0.32269,18.0),		float4(0.577419,0.408182,0.707089,19.0),
	float4(-0.0945428,0.341843,-0.934989,20.0),		float4(0.788332,-0.60845,-0.0912217,21.0),
	float4(-0.346889,0.894997,-0.280445,22.0),		float4(-0.165907,-0.649857,0.741728,23.0),
	float4(0.791885,0.124138,0.597919,24.0),		float4(-0.625952,0.73148,0.270409,25.0),
	float4(-0.556306,0.580363,0.594729,26.0),		float4(0.673523,0.719805,0.168069,27.0),
	float4(-0.420334,0.894265,0.153656,28.0),		float4(-0.141622,-0.279389,0.949676,29.0),
	float4(-0.803343,0.458278,0.380291,30.0),		float4(0.49355,-0.402088,0.77119,31.0)
};

// this is the smoothstep function f(t) = 3t^2 - 2t^3, without the normalization
float3 s_curve(float3 t)
{
	return t*t*(float3(3.0, 3.0, 3.0) - float3(2.0, 2.0, 2.0)*t);
}

float2 s_curve(float2 t)
{
	return t*t*(float2(3.0, 3.0) - float2(2.0, 2.0)*t);
}

float s_curve(float t)
{
	return t*t*(3.0 - 2.0*t);
}
// 2D version
float noise(float2 v)
{
	v = v + float2(10000.0, 10000.0);

	float2 i = frac(v * BR) * float(B);   // index between 0 and B-1
	float2 f = frac(v);            // fractional position

								  // lookup in permutation table
	float2 p;
	p[0] = pg[int(i[0])].w;
	p[1] = pg[int(i[0]) + 1].w;
	p = p + i[1];

	// compute dot products between gradients and floattors
	float4 r;
	r[0] = dot(pg[int(p[0])].xy, f);
	r[1] = dot(pg[int(p[1])].xy, f - float2(1.0, 0.0));
	r[2] = dot(pg[int(p[0]) + 1].xy, f - float2(0.0, 1.0));
	r[3] = dot(pg[int(p[1]) + 1].xy, f - float2(1.0, 1.0));

	// interpolate
	f = s_curve(f);
	r = lerp(r.xyyy, r.zwww, f[1]);
	return lerp(r.x, r.y, f[0]);
}

float rand(float2 co) {
	return 0.5 + (frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453))*0.5;
}

// The entry point for our vertex shader
VertexToPixel main(VertexShaderInput input)
{
    // Set up output
    VertexToPixel output;
	
	input.position += input.normal * (noise(input.uv*id*0.001f)*2 - 1);

    // Calculate output position
    matrix worldViewProj = mul(mul(world, view), projection);
    output.position = mul(float4(input.position, 1.0f), worldViewProj);

    // Take into account rotation (but not translation)
    // Most of the  world matrix
    output.normal = mul(input.normal, (float3x3)world);

    // The world space position of the vertex
    output.worldPos = mul(float4(input.position, 1), world).xyz;

    // Pass the UV's through
    output.uv = input.uv * (noise(input.uv*id*0.001f) * 10 - 5);

    return output;
}
